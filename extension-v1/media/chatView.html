<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RepoMind</title>
    <link href="styles.css" rel="stylesheet">
    <style>
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes blink {
            0% { opacity: 0.2; }
            20% { opacity: 1; }
            100% { opacity: 0.2; }
        }

        .loading-dots span {
            animation: blink 1.4s infinite both;
            display: inline-block;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            margin-right: 3px;
            background-color: #0078d4;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .image-container {
            margin: 10px 0;
            text-align: center;
        }

        .chat-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .chat-image:hover {
            transform: scale(1.02);
        }

        /* Enhanced styling for formatted messages */
        .assistant-message h1 {
            font-size: 1.5em;
            margin: 0.8em 0 0.4em 0;
            color: #0078d4;
            border-bottom: 1px solid #eaeaea;
            padding-bottom: 0.2em;
        }

        .assistant-message h2 {
            font-size: 1.3em;
            margin: 0.7em 0 0.3em 0;
            color: #0078d4;
        }

        .assistant-message h3 {
            font-size: 1.1em;
            margin: 0.6em 0 0.3em 0;
            color: #0078d4;
        }

        .assistant-message ul, .assistant-message ol {
            padding-left: 1.5em;
            margin: 0.5em 0;
        }

        .assistant-message li {
            margin-bottom: 0.3em;
        }

        .assistant-message code {
            background-color: #f3f3f3;
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .assistant-message pre {
            background-color: #f3f3f3;
            padding: 0.8em;
            border-radius: 5px;
            overflow-x: auto;
            margin: 0.7em 0;
        }

        .assistant-message pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
            white-space: pre-wrap;
        }

        /* Enhanced progress bar */
        .progress-container {
            width: 100%;
            background-color: var(--vscode-editor-background);
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
            border: 1px solid var(--vscode-widget-border);
        }

        .progress-bar {
            height: 6px;
            background: linear-gradient(90deg, var(--vscode-progressBar-background), var(--vscode-button-background));
            border-radius: 4px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-bar.enhanced {
            background: linear-gradient(90deg, #22c55e, #3b82f6, #8b5cf6);
            background-size: 200% 100%;
            animation: progressGradient 2s ease-in-out infinite;
        }

        @keyframes progressGradient {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .progress-text {
            font-size: 11px;
            color: var(--vscode-descriptionForeground);
            margin-top: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .progress-stage {
            font-weight: 500;
            color: var(--vscode-foreground);
        }

        .progress-percentage {
            font-family: monospace;
            color: var(--vscode-button-background);
        }

        /* Enhanced loading states */
        .loading-enhanced {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--vscode-widget-border);
            border-top: 2px solid var(--vscode-button-background);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-spinner.enhanced {
            border-top-color: #22c55e;
            border-right-color: #3b82f6;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error states */
        .message.error {
            border-left: 4px solid #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
        }

        .error-icon {
            color: #ef4444;
            font-weight: bold;
            margin-right: 8px;
        }

        /* Cache indicator */
        .cache-indicator {
            font-size: 10px;
            color: var(--vscode-descriptionForeground);
            background-color: var(--vscode-badge-background);
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 8px;
        }

        /* Enhanced text formatting */
        .assistant-message {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .assistant-message h1,
        .assistant-message h2,
        .assistant-message h3 {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .assistant-message ul,
        .assistant-message ol {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .assistant-message li {
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: left;
        }

        .assistant-message p {
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: left;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <div class="welcome-message">
            <h2>Welcome to RepoMind</h2>
            <p>I can help you with coding tasks, answer questions, and generate code based on your requirements.</p>
            <p>Try asking about:</p>
            <ul>
                <li>Code implementation</li>
                <li>Debugging help</li>
                <li>Best practices</li>
            </ul>
        </div>
        <div id="message-history"></div>
    </div>
    <div class="action-buttons">
        <button id="sync-button" class="action-button">Sync Codebase</button>
        <button id="attach-button" class="action-button">Attach File</button>
        <button id="visualize-button" class="action-button">Show Visualizations</button>
        <button id="clear-history-button" class="action-button" title="Clear conversation history">Clear History</button>
    </div>
    <div class="input-container">
        <textarea id="message-input" placeholder="Type your message here..."></textarea>
        <button id="send-button">Send</button>
    </div>

    <script>
        const vscode = acquireVsCodeApi();
        const messageHistory = document.getElementById('message-history');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');

        // Add a global function to open files
        window.vscode = {
            open: function(filePath) {
                vscode.postMessage({
                    command: 'openFile',
                    path: filePath
                });
            }
        };

        // Get references to the new buttons
        const syncButton = document.getElementById('sync-button');
        const attachButton = document.getElementById('attach-button');
        const visualizeButton = document.getElementById('visualize-button');
        const clearHistoryButton = document.getElementById('clear-history-button');

        // Send message when button is clicked
        sendButton.addEventListener('click', sendMessage);

        // Send message when Enter key is pressed (but allow Shift+Enter for new lines)
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Add event listeners for the new buttons
        syncButton.addEventListener('click', () => {
            console.log('Sync button clicked');
            vscode.postMessage({
                command: 'syncCodebase'
            });
        });

        attachButton.addEventListener('click', () => {
            console.log('Attach button clicked');
            vscode.postMessage({
                command: 'attachFile'
            });
        });

        visualizeButton.addEventListener('click', () => {
            vscode.postMessage({
                command: 'visualizeRelationships'
            });
        });

        clearHistoryButton.addEventListener('click', () => {
            // Ask for confirmation before clearing history
            const confirmClear = confirm('Are you sure you want to clear the conversation history? This cannot be undone.');
            if (confirmClear) {
                vscode.postMessage({
                    command: 'clearHistory'
                });
            }
        });

        // Handle messages from the extension
        window.addEventListener('message', function(event) {
            const message = event.data;
            console.log('Received message from extension:', message);

            if (message.command === 'addMessage' || message.command === 'ADD_MESSAGE') {
                // Generate a unique ID for the message if not provided
                const messageId = message.id || 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                addMessage(
                    message.text,
                    message.isUser === true,
                    message.imagePath,
                    message.isImage === true,
                    message.imageUri,
                    message.imageCaption,
                    message.isLoading === true,
                    message.loadingType,
                    messageId
                );
            } else if (message.command === 'updateMessage' || message.command === 'UPDATE_MESSAGE') {
                // Find and update an existing message with enhanced progress support
                updateMessage(message.id, message.text, message.isLoading, message.progress, message.stage, message.isError);
            } else if (message.command === 'openImage') {
                vscode.postMessage({
                    command: 'openImage',
                    path: message.path
                });
            } else if (message.command === 'openFile') {
                vscode.postMessage({
                    command: 'openFile',
                    path: message.path
                });
            } else if (message.command === 'runMergeAgent') {
                console.log('Received runMergeAgent command, forwarding to extension');
                vscode.postMessage({
                    command: 'runMergeAgent'
                });
            }
        });

        function sendMessage() {
            const text = messageInput.value.trim();
            if (text) {
                // Send message to extension (don't add to UI here - let the extension handle it)
                vscode.postMessage({
                    command: 'sendMessage',
                    text: text
                });

                // Clear input
                messageInput.value = '';
            }
        }

        function addMessage(text, isUser, imagePath, isImage, imageUri, imageCaption, isLoading, loadingType, messageId) {
            const messageElement = document.createElement('div');
            messageElement.className = isUser ? 'user-message' : 'assistant-message';

            // Set the message ID as a data attribute for later reference
            if (messageId) {
                messageElement.setAttribute('data-message-id', messageId);
            }

            // Add a loading indicator if requested
            if (isLoading && !isUser) {
                // Add text with loading indicator
                const textNode = document.createElement('div');
                textNode.textContent = text;
                textNode.style.marginBottom = '8px';
                messageElement.appendChild(textNode);

                // Create enhanced loading container
                const loadingContainer = document.createElement('div');
                loadingContainer.className = 'loading-enhanced';

                // Add spinner
                const spinner = document.createElement('div');
                spinner.className = loadingType === 'enhanced' ? 'loading-spinner enhanced' : 'loading-spinner';
                loadingContainer.appendChild(spinner);

                // Add loading text
                const loadingText = document.createElement('div');
                loadingText.style.flex = '1';
                loadingText.style.fontStyle = 'italic';
                loadingText.style.color = '#666';

                // Different loading messages based on the loading type
                if (loadingType === 'sync') {
                    loadingText.textContent = 'Please wait while the codebase is being analyzed...';
                } else if (loadingType === 'llm') {
                    loadingText.textContent = 'Searching the codebase for relevant information and generating a response...';
                } else if (loadingType === 'enhanced') {
                    loadingText.textContent = 'Processing with enhanced features...';
                } else {
                    loadingText.textContent = 'Processing your request...';
                }

                loadingContainer.appendChild(loadingText);

                // Add progress bar for enhanced loading
                if (loadingType === 'enhanced') {
                    const progressContainer = document.createElement('div');
                    progressContainer.className = 'progress-container';

                    const progressBar = document.createElement('div');
                    progressBar.className = 'progress-bar enhanced';
                    progressBar.style.width = '0%';
                    progressContainer.appendChild(progressBar);

                    const progressText = document.createElement('div');
                    progressText.className = 'progress-text';
                    progressText.innerHTML = `
                        <span class="progress-stage">Initializing</span>
                        <span class="progress-percentage">0%</span>
                    `;
                    progressContainer.appendChild(progressText);

                    messageElement.appendChild(loadingContainer);
                    messageElement.appendChild(progressContainer);
                } else {
                    // Add animated dots for non-enhanced loading
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'loading-dots';
                    dotsContainer.style.marginTop = '8px';
                    dotsContainer.style.textAlign = 'center';

                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('span');
                        dotsContainer.appendChild(dot);
                    }

                    loadingContainer.appendChild(dotsContainer);
                    messageElement.appendChild(loadingContainer);
                }

                // Add the message to the history
                messageHistory.appendChild(messageElement);

                // Scroll to bottom
                messageHistory.scrollTop = messageHistory.scrollHeight;

                // Add a subtle animation to show the message has been added
                messageElement.style.animation = 'slideIn 0.3s';

                return; // Skip the rest of the function
            }

            // Check if this is an image message (either by flag or content)
            if (!isUser && (isImage || text.includes('![IMAGE]'))) {
                // Parse the image path from the message if not directly provided
                let imageSrc = imageUri;
                let processedText = text;

                if (!imageSrc) {
                    const regex = /!\[IMAGE\]\((.*?)\)/g;
                    let match;

                    while ((match = regex.exec(text)) !== null) {
                        imageSrc = match[1];
                        const imageTag = match[0];
                        // Remove the image tag from the text
                        processedText = processedText.replace(imageTag, '');
                    }
                }

                // If we have a caption but no processed text, use the caption
                if (!processedText.trim() && imageCaption) {
                    processedText = imageCaption;
                }

                // Add the text part first if it exists
                if (processedText.trim()) {
                    const textNode = document.createElement('div');
                    textNode.textContent = processedText.trim();
                    textNode.style.marginBottom = '8px';
                    messageElement.appendChild(textNode);
                }

                // Create image container and image element
                const imageContainer = document.createElement('div');
                imageContainer.className = 'image-container';

                // Create a loading message
                const loadingText = document.createElement('div');
                loadingText.textContent = 'Loading visualization...';
                loadingText.style.padding = '10px';
                loadingText.style.textAlign = 'center';
                loadingText.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                loadingText.style.borderRadius = '4px';
                imageContainer.appendChild(loadingText);

                const image = document.createElement('img');
                image.className = 'chat-image';
                image.src = imageSrc;
                image.alt = imageCaption || 'Code Visualization';
                image.title = 'Click to open in external viewer';
                image.style.maxWidth = '100%';
                image.style.height = 'auto';
                image.style.display = 'block';
                image.style.margin = '0 auto';
                image.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.15)';
                image.style.borderRadius = '4px';

                // Add onload event to remove loading message and show success
                image.onload = () => {
                    if (loadingText.parentNode === imageContainer) {
                        imageContainer.removeChild(loadingText);
                    }
                    console.log('Image loaded successfully:', imageSrc);

                    // Add a subtle animation to show the image has loaded
                    image.style.animation = 'fadeIn 0.5s';
                };

                // Add onerror event to show error message
                image.onerror = () => {
                    console.error('Error loading image:', imageSrc);
                    loadingText.textContent = 'Error loading visualization. Click to try opening externally.';
                    loadingText.style.color = '#ff6b6b';
                    loadingText.style.border = '1px solid #ff6b6b';
                    loadingText.style.padding = '12px';

                    // Add a retry button
                    const retryButton = document.createElement('button');
                    retryButton.textContent = 'Retry';
                    retryButton.style.marginTop = '8px';
                    retryButton.style.padding = '4px 12px';
                    retryButton.style.backgroundColor = '#0078d4';
                    retryButton.style.color = 'white';
                    retryButton.style.border = 'none';
                    retryButton.style.borderRadius = '4px';
                    retryButton.style.cursor = 'pointer';

                    retryButton.addEventListener('click', () => {
                        // Try loading the image again with a cache-busting parameter
                        image.src = imageSrc + '?retry=' + new Date().getTime();
                    });

                    // Add an open externally button
                    const openExternalButton = document.createElement('button');
                    openExternalButton.textContent = 'Open Externally';
                    openExternalButton.style.marginTop = '8px';
                    openExternalButton.style.marginLeft = '8px';
                    openExternalButton.style.padding = '4px 12px';
                    openExternalButton.style.backgroundColor = '#107C10';
                    openExternalButton.style.color = 'white';
                    openExternalButton.style.border = 'none';
                    openExternalButton.style.borderRadius = '4px';
                    openExternalButton.style.cursor = 'pointer';

                    openExternalButton.addEventListener('click', () => {
                        // Open the image externally
                        vscode.postMessage({
                            command: 'openImage',
                            path: pathToOpen
                        });
                    });

                    loadingText.appendChild(document.createElement('br'));
                    loadingText.appendChild(retryButton);
                    loadingText.appendChild(openExternalButton);

                    // Also try an alternative approach - create an img element with a direct src
                    setTimeout(() => {
                        if (image.naturalWidth === 0) {
                            console.log('Trying alternative image loading approach');
                            const directImg = document.createElement('img');
                            directImg.src = imageSrc + '?direct=' + Date.now();
                            directImg.style.display = 'none';
                            document.body.appendChild(directImg);

                            directImg.onload = () => {
                                console.log('Direct image loaded successfully');
                                image.src = directImg.src;
                                document.body.removeChild(directImg);
                            };
                        }
                    }, 2000);
                };

                // Use the original path for opening externally
                const pathToOpen = imagePath || imageSrc;

                // Add click event to open the image in external viewer
                image.addEventListener('click', () => {
                    vscode.postMessage({
                        command: 'openImage',
                        path: pathToOpen
                    });
                });

                // Also make the loading text clickable
                loadingText.style.cursor = 'pointer';
                loadingText.addEventListener('click', () => {
                    vscode.postMessage({
                        command: 'openImage',
                        path: pathToOpen
                    });
                });

                imageContainer.appendChild(image);
                messageElement.appendChild(imageContainer);

                // Add a caption below the image if not already included in the text
                if (imageCaption && !processedText.includes(imageCaption)) {
                    const captionElement = document.createElement('div');
                    captionElement.textContent = imageCaption;
                    captionElement.style.textAlign = 'center';
                    captionElement.style.fontStyle = 'italic';
                    captionElement.style.marginTop = '4px';
                    captionElement.style.color = '#666';
                    messageElement.appendChild(captionElement);
                }

                // Add a link to open externally
                const openLink = document.createElement('div');
                openLink.className = 'image-link';
                openLink.textContent = 'Open visualization externally';
                openLink.style.color = '#0078d4';
                openLink.style.cursor = 'pointer';
                openLink.style.marginTop = '8px';
                openLink.style.textAlign = 'center';
                openLink.style.fontSize = '12px';

                openLink.addEventListener('click', () => {
                    vscode.postMessage({
                        command: 'openImage',
                        path: pathToOpen
                    });
                });

                messageElement.appendChild(openLink);
            } else {
                // Check if this is an assistant message (for Markdown rendering)
                if (!isUser) {
                    // Check if the text contains actual HTML elements (not markdown)
                    const containsHTML = text.includes('<div') || text.includes('<h1') || text.includes('<h2') ||
                                        text.includes('<h3') || text.includes('<p>') || text.includes('<ul') ||
                                        text.includes('<ol') || text.includes('<li') || text.includes('<table') ||
                                        text.includes('<pre') || text.includes('<code') || text.includes('<button');

                    if (containsHTML) {
                        // If the text already contains HTML, use it directly
                        messageElement.innerHTML = text;

                        // After setting the HTML, attach event listeners to any buttons
                        setTimeout(() => {
                            // Find all buttons in the message
                            const buttons = messageElement.querySelectorAll('button');

                            buttons.forEach(button => {
                                // Check if this is the Run Merge Agent button
                                if (button.id === 'run-merge-agent') {
                                    console.log('Found Run Merge Agent button, attaching event listener');

                                    // Add the event listener
                                    button.addEventListener('click', () => {
                                        console.log('Run Merge Agent button clicked');
                                        vscode.postMessage({
                                            command: 'runMergeAgent'
                                        });
                                    });
                                }

                                // Check if this is the Open LLM Instructions File button
                                if (button.id === 'open-llm-file') {
                                    console.log('Found Open LLM Instructions File button, attaching event listener');

                                    // Get the file path from the data attribute
                                    const filePath = button.getAttribute('data-path');

                                    // Add the event listener
                                    button.addEventListener('click', () => {
                                        console.log('Open LLM Instructions File button clicked, path:', filePath);
                                        vscode.postMessage({
                                            command: 'openFile',
                                            path: filePath
                                        });
                                    });
                                }
                            });
                        }, 0);
                    } else {
                        // Comprehensive Markdown rendering for ALL LLM output types
                        let formattedText = text;

                        // 1. Handle code blocks first (protect from other transformations)
                        formattedText = formattedText.replace(/```(\w+)?\n?([\s\S]*?)```/g, '<pre style="background-color: var(--vscode-textCodeBlock-background); padding: 8px 10px; border-radius: 4px; margin: 8px 0; overflow-x: auto; border-left: 3px solid var(--vscode-textLink-foreground); font-size: 0.9em;"><code style="font-family: \'Courier New\', Consolas, monospace; white-space: pre; line-height: 1.4; color: var(--vscode-textPreformat-foreground);">$2</code></pre>');

                        // 2. Handle all heading levels with proper hierarchy (compact spacing)
                        formattedText = formattedText.replace(/^#{6}\s+(.*$)/gm, '<h6 style="margin: 3px 0 1px 0; color: var(--vscode-textLink-foreground); font-weight: 500; font-size: 0.85em; opacity: 0.9;">$1</h6>');
                        formattedText = formattedText.replace(/^#{5}\s+(.*$)/gm, '<h5 style="margin: 4px 0 1px 0; color: var(--vscode-textLink-foreground); font-weight: 500; font-size: 0.9em; opacity: 0.95;">$1</h5>');
                        formattedText = formattedText.replace(/^#{4}\s+(.*$)/gm, '<h4 style="margin: 5px 0 2px 0; color: var(--vscode-textLink-foreground); font-weight: 600; font-size: 0.95em; border-bottom: 1px solid var(--vscode-widget-border); padding-bottom: 1px;">$1</h4>');
                        formattedText = formattedText.replace(/^#{3}\s+(.*$)/gm, '<h3 style="margin: 6px 0 2px 0; color: var(--vscode-textLink-foreground); font-weight: 600; font-size: 1.0em; border-bottom: 1px solid var(--vscode-widget-border); padding-bottom: 2px;">$1</h3>');
                        formattedText = formattedText.replace(/^#{2}\s+(.*$)/gm, '<h2 style="margin: 8px 0 3px 0; color: var(--vscode-textLink-foreground); font-weight: 700; font-size: 1.1em; border-bottom: 2px solid var(--vscode-textLink-foreground); padding-bottom: 2px;">$1</h2>');
                        formattedText = formattedText.replace(/^#{1}\s+(.*$)/gm, '<h1 style="margin: 10px 0 4px 0; color: var(--vscode-textLink-foreground); font-weight: 700; font-size: 1.2em; border-bottom: 3px solid var(--vscode-textLink-foreground); padding-bottom: 3px;">$1</h1>');

                        // 3. Handle ALL types of lists with proper nesting and formatting
                        const lines = formattedText.split('\n');
                        const processedLines = [];
                        let listStack = []; // Stack to handle nested lists

                        // Helper function to handle list nesting levels
                        const handleListLevel = (processedLines, listStack, indent, listType) => {
                            // Close lists that are at a deeper or equal level
                            while (listStack.length > 0 && listStack[listStack.length - 1].indent >= indent) {
                                const closingList = listStack.pop();
                                processedLines.push(`</${closingList.type}>`);
                            }

                            // Open new list if needed
                            if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                                const listStyle = listType === 'ul' ?
                                    'margin: 2px 0; padding-left: 20px; list-style-type: disc;' :
                                    'margin: 2px 0; padding-left: 20px;';
                                processedLines.push(`<${listType} style="${listStyle}">`);
                                listStack.push({ type: listType, indent: indent });
                            }
                        };

                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];

                            // Match different list patterns with indentation
                            const unorderedMatch = line.match(/^(\s*)[-*+]\s+(.*)$/);
                            const orderedMatch = line.match(/^(\s*)(\d+)\.\s+(.*)$/);
                            const checkboxMatch = line.match(/^(\s*)[-*+]\s+\[([ xX])\]\s+(.*)$/);
                            const dashMatch = line.match(/^(\s*)[-–—]\s+(.*)$/);

                            if (checkboxMatch) {
                                // Handle checkboxes
                                const indent = checkboxMatch[1].length;
                                const checked = checkboxMatch[2].toLowerCase() === 'x';
                                const content = checkboxMatch[3];
                                const checkIcon = checked ? '☑️' : '☐';

                                handleListLevel(processedLines, listStack, indent, 'ul');
                                processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground); list-style: none;"><span style="margin-right: 6px;">${checkIcon}</span>${content}</li>`);

                            } else if (unorderedMatch) {
                                // Handle unordered lists (-, *, +)
                                const indent = unorderedMatch[1].length;
                                const content = unorderedMatch[2];

                                handleListLevel(processedLines, listStack, indent, 'ul');
                                processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground);">${content}</li>`);

                            } else if (orderedMatch) {
                                // Handle ordered lists (1., 2., etc.)
                                const indent = orderedMatch[1].length;
                                const content = orderedMatch[3];

                                handleListLevel(processedLines, listStack, indent, 'ol');
                                processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground);">${content}</li>`);

                            } else if (dashMatch) {
                                // Handle em-dash lists
                                const indent = dashMatch[1].length;
                                const content = dashMatch[2];

                                handleListLevel(processedLines, listStack, indent, 'ul');
                                processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground); list-style-type: none;"><span style="margin-right: 6px;">—</span>${content}</li>`);

                            } else {
                                // Close all open lists when encountering non-list content
                                while (listStack.length > 0) {
                                    const listInfo = listStack.pop();
                                    processedLines.push(`</${listInfo.type}>`);
                                }
                                processedLines.push(line);
                            }
                        }

                        // Close any remaining open lists
                        while (listStack.length > 0) {
                            const listInfo = listStack.pop();
                            processedLines.push(`</${listInfo.type}>`);
                        }

                        formattedText = processedLines.join('\n');

                        // 4. Handle ALL table formats (markdown tables, ASCII tables, etc.)
                        // Handle markdown tables
                        const tableLines = formattedText.split('\n');
                        const processedTableLines = [];
                        let inTable = false;
                        let tableRows = [];

                        for (let i = 0; i < tableLines.length; i++) {
                            const line = tableLines[i].trim();

                            // Check if line looks like a table row
                            if (line.includes('|') && line.split('|').length > 2) {
                                if (!inTable) {
                                    inTable = true;
                                    tableRows = [];
                                }

                                // Skip separator rows (---|---|---)
                                if (line.match(/^\|?[\s\-\|:]+\|?$/)) {
                                    continue;
                                }

                                const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
                                if (cells.length > 0) {
                                    tableRows.push(cells);
                                }
                            } else {
                                // End of table
                                if (inTable && tableRows.length > 0) {
                                    // Generate table HTML
                                    let tableHTML = '<table style="border-collapse: collapse; margin: 4px 0; width: 100%; font-size: 0.9em; border: 1px solid var(--vscode-widget-border);">';

                                    tableRows.forEach((row, rowIndex) => {
                                        const isHeader = rowIndex === 0;
                                        const cellTag = isHeader ? 'th' : 'td';
                                        const cellStyle = isHeader ?
                                            'padding: 4px 8px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-textCodeBlock-background); font-weight: 600; color: var(--vscode-textLink-foreground);' :
                                            'padding: 4px 8px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-editor-background);';

                                        const cellElements = row.map(cell => `<${cellTag} style="${cellStyle}">${cell}</${cellTag}>`).join('');
                                        tableHTML += `<tr>${cellElements}</tr>`;
                                    });

                                    tableHTML += '</table>';
                                    processedTableLines.push(tableHTML);
                                    tableRows = [];
                                }
                                inTable = false;
                                processedTableLines.push(line);
                            }
                        }

                        // Handle any remaining table
                        if (inTable && tableRows.length > 0) {
                            let tableHTML = '<table style="border-collapse: collapse; margin: 8px 0; width: 100%; font-size: 0.9em; border: 1px solid var(--vscode-widget-border);">';
                            tableRows.forEach((row, rowIndex) => {
                                const isHeader = rowIndex === 0;
                                const cellTag = isHeader ? 'th' : 'td';
                                const cellStyle = isHeader ?
                                    'padding: 6px 10px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-textCodeBlock-background); font-weight: 600; color: var(--vscode-textLink-foreground);' :
                                    'padding: 6px 10px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-editor-background);';

                                const cellElements = row.map(cell => `<${cellTag} style="${cellStyle}">${cell}</${cellTag}>`).join('');
                                tableHTML += `<tr>${cellElements}</tr>`;
                            });
                            tableHTML += '</table>';
                            processedTableLines.push(tableHTML);
                        }

                        formattedText = processedTableLines.join('\n');

                        // 5. Handle ALL inline formatting and special elements

                        // Bold text (** or __)
                        formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600; color: var(--vscode-textLink-foreground);">$1</strong>');
                        formattedText = formattedText.replace(/__(.*?)__/g, '<strong style="font-weight: 600; color: var(--vscode-textLink-foreground);">$1</strong>');

                        // Italic text (* or _)
                        formattedText = formattedText.replace(/\*(.*?)\*/g, '<em style="font-style: italic; color: var(--vscode-foreground);">$1</em>');
                        formattedText = formattedText.replace(/_(.*?)_/g, '<em style="font-style: italic; color: var(--vscode-foreground);">$1</em>');

                        // Strikethrough (~~)
                        formattedText = formattedText.replace(/~~(.*?)~~/g, '<del style="text-decoration: line-through; opacity: 0.7;">$1</del>');

                        // Inline code (`)
                        formattedText = formattedText.replace(/`([^`]+)`/g, '<code style="background-color: var(--vscode-textCodeBlock-background); padding: 2px 4px; border-radius: 3px; font-family: \'Courier New\', Consolas, monospace; font-size: 0.9em; color: var(--vscode-textPreformat-foreground);">$1</code>');

                        // Links [text](url)
                        formattedText = formattedText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: var(--vscode-textLink-foreground); text-decoration: underline;" target="_blank">$1</a>');

                        // Auto-links (http/https URLs)
                        formattedText = formattedText.replace(/(https?:\/\/[^\s<>"]+)/g, '<a href="$1" style="color: var(--vscode-textLink-foreground); text-decoration: underline;" target="_blank">$1</a>');

                        // Highlight/mark text (==text==)
                        formattedText = formattedText.replace(/==(.*?)==/g, '<mark style="background-color: var(--vscode-editor-findMatchHighlightBackground); padding: 1px 2px; border-radius: 2px;">$1</mark>');

                        // Subscript (H~2~O)
                        formattedText = formattedText.replace(/~([^~]+)~/g, '<sub style="font-size: 0.8em;">$1</sub>');

                        // Superscript (x^2^)
                        formattedText = formattedText.replace(/\^([^^]+)\^/g, '<sup style="font-size: 0.8em;">$1</sup>');

                        // 6. Handle special formatting patterns and elements

                        // Horizontal rules (---, ***, ===)
                        formattedText = formattedText.replace(/^={3,}$/gm, '<hr style="border: none; border-top: 2px solid var(--vscode-textLink-foreground); margin: 10px 0;">');
                        formattedText = formattedText.replace(/^-{3,}$/gm, '<hr style="border: none; border-top: 1px solid var(--vscode-widget-border); margin: 8px 0;">');
                        formattedText = formattedText.replace(/^\*{3,}$/gm, '<hr style="border: none; border-top: 1px dashed var(--vscode-widget-border); margin: 8px 0;">');

                        // Blockquotes (> text)
                        formattedText = formattedText.replace(/^>\s+(.*)$/gm, '<blockquote style="border-left: 4px solid var(--vscode-textLink-foreground); margin: 8px 0; padding: 8px 12px; background-color: var(--vscode-textCodeBlock-background); font-style: italic; opacity: 0.9;">$1</blockquote>');

                        // Keyboard keys ([Ctrl], [Alt], etc.)
                        formattedText = formattedText.replace(/\[([A-Za-z0-9+\-\s]+)\]/g, '<kbd style="background-color: var(--vscode-textCodeBlock-background); border: 1px solid var(--vscode-widget-border); border-radius: 3px; padding: 2px 6px; font-family: monospace; font-size: 0.9em; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">$1</kbd>');

                        // Emoji shortcuts (:warning:, :info:, etc.)
                        const emojiMap = {
                            ':warning:': '⚠️', ':info:': 'ℹ️', ':check:': '✅', ':cross:': '❌',
                            ':star:': '⭐', ':fire:': '🔥', ':rocket:': '🚀', ':bulb:': '💡',
                            ':gear:': '⚙️', ':lock:': '🔒', ':key:': '🔑', ':shield:': '🛡️',
                            ':bug:': '🐛', ':wrench:': '🔧', ':hammer:': '🔨', ':package:': '📦',
                            ':folder:': '📁', ':file:': '📄', ':link:': '🔗', ':arrow:': '➡️'
                        };

                        Object.entries(emojiMap).forEach(([shortcode, emoji]) => {
                            formattedText = formattedText.replace(new RegExp(shortcode.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), emoji);
                        });

                        // Handle paragraphs and line breaks with compact spacing
                        formattedText = formattedText.replace(/\n\n+/g, '</p><p style="margin: 3px 0; line-height: 1.4;">');
                        formattedText = formattedText.replace(/\n/g, '<br>');

                        // Wrap in paragraph if it doesn't start with a block element
                        if (!formattedText.match(/^<(h[1-6]|ul|ol|pre|div)/)) {
                            formattedText = '<p style="margin: 2px 0; line-height: 1.4; color: var(--vscode-foreground);">' + formattedText + '</p>';
                        }

                        // Post-process to eliminate spacing between consecutive elements
                        formattedText = formattedText
                            // Remove ALL spacing between heading and list
                            .replace(/<\/h[1-6]>\s*<ul/g, '</h3><ul style="margin-top: 0;"')
                            .replace(/<\/h[1-6]>\s*<ol/g, '</h3><ol style="margin-top: 0;"')
                            // Remove spacing between lists and headings
                            .replace(/<\/ul>\s*<h/g, '</ul><h')
                            .replace(/<\/ol>\s*<h/g, '</ol><h')
                            // Remove spacing between consecutive lists
                            .replace(/<\/ul>\s*<ul/g, '</ul><ul style="margin-top: 0;"')
                            .replace(/<\/ol>\s*<ol/g, '</ol><ol style="margin-top: 0;"')
                            // Remove spacing between paragraphs and lists
                            .replace(/<\/p>\s*<ul/g, '</p><ul style="margin-top: 0;"')
                            .replace(/<\/p>\s*<ol/g, '</p><ol style="margin-top: 0;"');

                        // Apply container styling with compact, professional presentation
                        const styledText = `
                            <div style="line-height: 1.5; font-family: var(--vscode-font-family); font-size: var(--vscode-font-size); word-wrap: break-word; overflow-wrap: break-word; max-width: 100%; padding: 6px 8px; background-color: var(--vscode-editor-background); border-radius: 4px; border-left: 3px solid var(--vscode-textLink-foreground);">
                                ${formattedText}
                            </div>
                        `;

                        messageElement.innerHTML = styledText;
                    }
                } else {
                    // Regular text message
                    messageElement.textContent = text;
                }
            }

            messageHistory.appendChild(messageElement);

            // Scroll to bottom
            messageHistory.scrollTop = messageHistory.scrollHeight;

            // Add a subtle animation to show the message has been added
            messageElement.style.animation = 'slideIn 0.3s';
        }

        function updateMessage(messageId, newText, isLoading, progress, stage, isError) {
            if (!messageId) return;

            // Find the message element by its ID
            const messageElement = document.querySelector("[data-message-id='" + messageId + "']");
            if (!messageElement) {
                console.error("Message with ID " + messageId + " not found");
                return;
            }

            // Handle error state
            if (isError) {
                messageElement.classList.add('error');
                if (!newText.includes('⚠️')) {
                    newText = '⚠️ ' + newText;
                }
            } else {
                messageElement.classList.remove('error');
            }

            // Handle progress updates for enhanced loading
            if (isLoading && typeof progress === 'number' && stage) {
                const progressContainer = messageElement.querySelector('.progress-container');
                if (progressContainer) {
                    const progressBar = progressContainer.querySelector('.progress-bar');
                    const progressText = progressContainer.querySelector('.progress-text');

                    if (progressBar) {
                        progressBar.style.width = progress + '%';
                    }

                    if (progressText) {
                        progressText.innerHTML = `
                            <span class="progress-stage">${stage}</span>
                            <span class="progress-percentage">${progress}%</span>
                        `;
                    }

                    // Update the main text
                    const textNode = messageElement.querySelector('div:first-child');
                    if (textNode) {
                        textNode.textContent = newText;
                    }

                    return; // Don't proceed with normal text update
                }
            }

            // Remove loading indicators if not loading anymore
            if (!isLoading) {
                const loadingContainer = messageElement.querySelector('.loading-enhanced');
                const progressContainer = messageElement.querySelector('.progress-container');

                if (loadingContainer) {
                    loadingContainer.remove();
                }
                if (progressContainer) {
                    progressContainer.remove();
                }
            }

            // Update the text content
            // If the message has child elements, we need to be careful not to remove them
            const hasChildren = messageElement.children.length > 0;

            // Check if the new text contains actual HTML elements (not markdown)
            const containsHTML = newText.includes('<div') || newText.includes('<h1') || newText.includes('<h2') ||
                                newText.includes('<h3') || newText.includes('<p>') || newText.includes('<ul') ||
                                newText.includes('<ol') || newText.includes('<li') || newText.includes('<table') ||
                                newText.includes('<pre') || newText.includes('<code') || newText.includes('<button');

            if (containsHTML) {
                // If the text contains HTML, use innerHTML
                messageElement.innerHTML = newText;

                // After updating the HTML, attach event listeners to any buttons
                setTimeout(() => {
                    // Find all buttons in the message
                    const buttons = messageElement.querySelectorAll('button');

                    buttons.forEach(button => {
                        // Check if this is the Run Merge Agent button
                        if (button.id === 'run-merge-agent') {
                            console.log('Found Run Merge Agent button, attaching event listener');

                            // Add the event listener
                            button.addEventListener('click', () => {
                                console.log('Run Merge Agent button clicked');
                                vscode.postMessage({
                                    command: 'runMergeAgent'
                                });
                            });
                        }

                        // Check if this is the Open LLM Instructions File button
                        if (button.id === 'open-llm-file') {
                            console.log('Found Open LLM Instructions File button, attaching event listener');

                            // Get the file path from the data attribute
                            const filePath = button.getAttribute('data-path');

                            // Add the event listener
                            button.addEventListener('click', () => {
                                console.log('Open LLM Instructions File button clicked, path:', filePath);
                                vscode.postMessage({
                                    command: 'openFile',
                                    path: filePath
                                });
                            });
                        }
                    });
                }, 0);
            } else {
                // Apply the same comprehensive markdown rendering as in addMessage
                let formattedText = newText;

                // 1. Handle code blocks first (protect from other transformations)
                formattedText = formattedText.replace(/```(\w+)?\n?([\s\S]*?)```/g, '<pre style="background-color: var(--vscode-textCodeBlock-background); padding: 8px 10px; border-radius: 4px; margin: 8px 0; overflow-x: auto; border-left: 3px solid var(--vscode-textLink-foreground); font-size: 0.9em;"><code style="font-family: \'Courier New\', Consolas, monospace; white-space: pre; line-height: 1.4; color: var(--vscode-textPreformat-foreground);">$2</code></pre>');

                // 2. Handle all heading levels with proper hierarchy (compact spacing)
                formattedText = formattedText.replace(/^#{6}\s+(.*$)/gm, '<h6 style="margin: 3px 0 1px 0; color: var(--vscode-textLink-foreground); font-weight: 500; font-size: 0.85em; opacity: 0.9;">$1</h6>');
                formattedText = formattedText.replace(/^#{5}\s+(.*$)/gm, '<h5 style="margin: 4px 0 1px 0; color: var(--vscode-textLink-foreground); font-weight: 500; font-size: 0.9em; opacity: 0.95;">$1</h5>');
                formattedText = formattedText.replace(/^#{4}\s+(.*$)/gm, '<h4 style="margin: 5px 0 2px 0; color: var(--vscode-textLink-foreground); font-weight: 600; font-size: 0.95em; border-bottom: 1px solid var(--vscode-widget-border); padding-bottom: 1px;">$1</h4>');
                formattedText = formattedText.replace(/^#{3}\s+(.*$)/gm, '<h3 style="margin: 6px 0 2px 0; color: var(--vscode-textLink-foreground); font-weight: 600; font-size: 1.0em; border-bottom: 1px solid var(--vscode-widget-border); padding-bottom: 2px;">$1</h3>');
                formattedText = formattedText.replace(/^#{2}\s+(.*$)/gm, '<h2 style="margin: 8px 0 3px 0; color: var(--vscode-textLink-foreground); font-weight: 700; font-size: 1.1em; border-bottom: 2px solid var(--vscode-textLink-foreground); padding-bottom: 2px;">$1</h2>');
                formattedText = formattedText.replace(/^#{1}\s+(.*$)/gm, '<h1 style="margin: 10px 0 4px 0; color: var(--vscode-textLink-foreground); font-weight: 700; font-size: 1.2em; border-bottom: 3px solid var(--vscode-textLink-foreground); padding-bottom: 3px;">$1</h1>');

                // 3. Handle ALL types of lists with proper nesting and formatting (same as addMessage)
                const lines = formattedText.split('\n');
                const processedLines = [];
                let listStack = []; // Stack to handle nested lists

                // Helper function to handle list nesting levels
                const handleListLevel = (processedLines, listStack, indent, listType) => {
                    // Close lists that are at a deeper or equal level
                    while (listStack.length > 0 && listStack[listStack.length - 1].indent >= indent) {
                        const closingList = listStack.pop();
                        processedLines.push(`</${closingList.type}>`);
                    }

                    // Open new list if needed
                    if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                        const listStyle = listType === 'ul' ?
                            'margin: 2px 0; padding-left: 20px; list-style-type: disc;' :
                            'margin: 2px 0; padding-left: 20px;';
                        processedLines.push(`<${listType} style="${listStyle}">`);
                        listStack.push({ type: listType, indent: indent });
                    }
                };

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    // Match different list patterns with indentation
                    const unorderedMatch = line.match(/^(\s*)[-*+]\s+(.*)$/);
                    const orderedMatch = line.match(/^(\s*)(\d+)\.\s+(.*)$/);
                    const checkboxMatch = line.match(/^(\s*)[-*+]\s+\[([ xX])\]\s+(.*)$/);
                    const dashMatch = line.match(/^(\s*)[-–—]\s+(.*)$/);

                    if (checkboxMatch) {
                        // Handle checkboxes
                        const indent = checkboxMatch[1].length;
                        const checked = checkboxMatch[2].toLowerCase() === 'x';
                        const content = checkboxMatch[3];
                        const checkIcon = checked ? '☑️' : '☐';

                        handleListLevel(processedLines, listStack, indent, 'ul');
                        processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground); list-style: none;"><span style="margin-right: 6px;">${checkIcon}</span>${content}</li>`);

                    } else if (unorderedMatch) {
                        // Handle unordered lists (-, *, +)
                        const indent = unorderedMatch[1].length;
                        const content = unorderedMatch[2];

                        handleListLevel(processedLines, listStack, indent, 'ul');
                        processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground);">${content}</li>`);

                    } else if (orderedMatch) {
                        // Handle ordered lists (1., 2., etc.)
                        const indent = orderedMatch[1].length;
                        const content = orderedMatch[3];

                        handleListLevel(processedLines, listStack, indent, 'ol');
                        processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground);">${content}</li>`);

                    } else if (dashMatch) {
                        // Handle em-dash lists
                        const indent = dashMatch[1].length;
                        const content = dashMatch[2];

                        handleListLevel(processedLines, listStack, indent, 'ul');
                        processedLines.push(`<li style="margin: 1px 0; line-height: 1.3; padding: 1px 0; color: var(--vscode-foreground); list-style-type: none;"><span style="margin-right: 6px;">—</span>${content}</li>`);

                    } else {
                        // Close all open lists when encountering non-list content
                        while (listStack.length > 0) {
                            const listInfo = listStack.pop();
                            processedLines.push(`</${listInfo.type}>`);
                        }
                        processedLines.push(line);
                    }
                }

                // Close any remaining open lists
                while (listStack.length > 0) {
                    const listInfo = listStack.pop();
                    processedLines.push(`</${listInfo.type}>`);
                }

                formattedText = processedLines.join('\n');

                // 4. Handle ALL table formats (markdown tables, ASCII tables, etc.) - same as addMessage
                // Handle markdown tables
                const tableLines = formattedText.split('\n');
                const processedTableLines = [];
                let inTable = false;
                let tableRows = [];

                for (let i = 0; i < tableLines.length; i++) {
                    const line = tableLines[i].trim();

                    // Check if line looks like a table row
                    if (line.includes('|') && line.split('|').length > 2) {
                        if (!inTable) {
                            inTable = true;
                            tableRows = [];
                        }

                        // Skip separator rows (---|---|---)
                        if (line.match(/^\|?[\s\-\|:]+\|?$/)) {
                            continue;
                        }

                        const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
                        if (cells.length > 0) {
                            tableRows.push(cells);
                        }
                    } else {
                        // End of table
                        if (inTable && tableRows.length > 0) {
                            // Generate table HTML
                            let tableHTML = '<table style="border-collapse: collapse; margin: 8px 0; width: 100%; font-size: 0.9em; border: 1px solid var(--vscode-widget-border);">';

                            tableRows.forEach((row, rowIndex) => {
                                const isHeader = rowIndex === 0;
                                const cellTag = isHeader ? 'th' : 'td';
                                const cellStyle = isHeader ?
                                    'padding: 6px 10px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-textCodeBlock-background); font-weight: 600; color: var(--vscode-textLink-foreground);' :
                                    'padding: 6px 10px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-editor-background);';

                                const cellElements = row.map(cell => `<${cellTag} style="${cellStyle}">${cell}</${cellTag}>`).join('');
                                tableHTML += `<tr>${cellElements}</tr>`;
                            });

                            tableHTML += '</table>';
                            processedTableLines.push(tableHTML);
                            tableRows = [];
                        }
                        inTable = false;
                        processedTableLines.push(line);
                    }
                }

                // Handle any remaining table
                if (inTable && tableRows.length > 0) {
                    let tableHTML = '<table style="border-collapse: collapse; margin: 8px 0; width: 100%; font-size: 0.9em; border: 1px solid var(--vscode-widget-border);">';
                    tableRows.forEach((row, rowIndex) => {
                        const isHeader = rowIndex === 0;
                        const cellTag = isHeader ? 'th' : 'td';
                        const cellStyle = isHeader ?
                            'padding: 6px 10px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-textCodeBlock-background); font-weight: 600; color: var(--vscode-textLink-foreground);' :
                            'padding: 6px 10px; border: 1px solid var(--vscode-widget-border); background-color: var(--vscode-editor-background);';

                        const cellElements = row.map(cell => `<${cellTag} style="${cellStyle}">${cell}</${cellTag}>`).join('');
                        tableHTML += `<tr>${cellElements}</tr>`;
                    });
                    tableHTML += '</table>';
                    processedTableLines.push(tableHTML);
                }

                formattedText = processedTableLines.join('\n');

                // 5. Handle ALL inline formatting and special elements

                // Bold text (** or __)
                formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600; color: var(--vscode-textLink-foreground);">$1</strong>');
                formattedText = formattedText.replace(/__(.*?)__/g, '<strong style="font-weight: 600; color: var(--vscode-textLink-foreground);">$1</strong>');

                // Italic text (* or _)
                formattedText = formattedText.replace(/\*(.*?)\*/g, '<em style="font-style: italic; color: var(--vscode-foreground);">$1</em>');
                formattedText = formattedText.replace(/_(.*?)_/g, '<em style="font-style: italic; color: var(--vscode-foreground);">$1</em>');

                // Strikethrough (~~)
                formattedText = formattedText.replace(/~~(.*?)~~/g, '<del style="text-decoration: line-through; opacity: 0.7;">$1</del>');

                // Inline code (`)
                formattedText = formattedText.replace(/`([^`]+)`/g, '<code style="background-color: var(--vscode-textCodeBlock-background); padding: 2px 4px; border-radius: 3px; font-family: \'Courier New\', Consolas, monospace; font-size: 0.9em; color: var(--vscode-textPreformat-foreground);">$1</code>');

                // Links [text](url)
                formattedText = formattedText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: var(--vscode-textLink-foreground); text-decoration: underline;" target="_blank">$1</a>');

                // Auto-links (http/https URLs)
                formattedText = formattedText.replace(/(https?:\/\/[^\s<>"]+)/g, '<a href="$1" style="color: var(--vscode-textLink-foreground); text-decoration: underline;" target="_blank">$1</a>');

                // Highlight/mark text (==text==)
                formattedText = formattedText.replace(/==(.*?)==/g, '<mark style="background-color: var(--vscode-editor-findMatchHighlightBackground); padding: 1px 2px; border-radius: 2px;">$1</mark>');

                // Subscript (H~2~O)
                formattedText = formattedText.replace(/~([^~]+)~/g, '<sub style="font-size: 0.8em;">$1</sub>');

                // Superscript (x^2^)
                formattedText = formattedText.replace(/\^([^^]+)\^/g, '<sup style="font-size: 0.8em;">$1</sup>');

                // 6. Handle special formatting patterns and elements

                // Horizontal rules (---, ***, ===)
                formattedText = formattedText.replace(/^={3,}$/gm, '<hr style="border: none; border-top: 2px solid var(--vscode-textLink-foreground); margin: 10px 0;">');
                formattedText = formattedText.replace(/^-{3,}$/gm, '<hr style="border: none; border-top: 1px solid var(--vscode-widget-border); margin: 8px 0;">');
                formattedText = formattedText.replace(/^\*{3,}$/gm, '<hr style="border: none; border-top: 1px dashed var(--vscode-widget-border); margin: 8px 0;">');

                // Blockquotes (> text)
                formattedText = formattedText.replace(/^>\s+(.*)$/gm, '<blockquote style="border-left: 4px solid var(--vscode-textLink-foreground); margin: 8px 0; padding: 8px 12px; background-color: var(--vscode-textCodeBlock-background); font-style: italic; opacity: 0.9;">$1</blockquote>');

                // Keyboard keys ([Ctrl], [Alt], etc.)
                formattedText = formattedText.replace(/\[([A-Za-z0-9+\-\s]+)\]/g, '<kbd style="background-color: var(--vscode-textCodeBlock-background); border: 1px solid var(--vscode-widget-border); border-radius: 3px; padding: 2px 6px; font-family: monospace; font-size: 0.9em; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">$1</kbd>');

                // Emoji shortcuts (:warning:, :info:, etc.)
                const emojiMap = {
                    ':warning:': '⚠️', ':info:': 'ℹ️', ':check:': '✅', ':cross:': '❌',
                    ':star:': '⭐', ':fire:': '🔥', ':rocket:': '🚀', ':bulb:': '💡',
                    ':gear:': '⚙️', ':lock:': '🔒', ':key:': '🔑', ':shield:': '🛡️',
                    ':bug:': '🐛', ':wrench:': '🔧', ':hammer:': '🔨', ':package:': '📦',
                    ':folder:': '📁', ':file:': '📄', ':link:': '🔗', ':arrow:': '➡️'
                };

                Object.entries(emojiMap).forEach(([shortcode, emoji]) => {
                    formattedText = formattedText.replace(new RegExp(shortcode.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), emoji);
                });

                // Handle paragraphs and line breaks with compact spacing
                formattedText = formattedText.replace(/\n\n+/g, '</p><p style="margin: 6px 0; line-height: 1.5;">');
                formattedText = formattedText.replace(/\n/g, '<br>');

                // Wrap in paragraph if it doesn't start with a block element
                if (!formattedText.match(/^<(h[1-6]|ul|ol|pre|div)/)) {
                    formattedText = '<p style="margin: 4px 0; line-height: 1.5; color: var(--vscode-foreground);">' + formattedText + '</p>';
                }

                // Post-process to eliminate spacing between consecutive elements
                formattedText = formattedText
                    // Remove ALL spacing between heading and list
                    .replace(/<\/h[1-6]>\s*<ul/g, '</h3><ul style="margin-top: 0;"')
                    .replace(/<\/h[1-6]>\s*<ol/g, '</h3><ol style="margin-top: 0;"')
                    // Remove spacing between lists and headings
                    .replace(/<\/ul>\s*<h/g, '</ul><h')
                    .replace(/<\/ol>\s*<h/g, '</ol><h')
                    // Remove spacing between consecutive lists
                    .replace(/<\/ul>\s*<ul/g, '</ul><ul style="margin-top: 0;"')
                    .replace(/<\/ol>\s*<ol/g, '</ol><ol style="margin-top: 0;"')
                    // Remove spacing between paragraphs and lists
                    .replace(/<\/p>\s*<ul/g, '</p><ul style="margin-top: 0;"')
                    .replace(/<\/p>\s*<ol/g, '</p><ol style="margin-top: 0;"');

                // Apply container styling with compact, professional presentation
                const styledText = `
                    <div style="line-height: 1.4; font-family: var(--vscode-font-family); font-size: var(--vscode-font-size); word-wrap: break-word; overflow-wrap: break-word; max-width: 100%; padding: 6px 8px; background-color: var(--vscode-editor-background); border-radius: 4px; border-left: 3px solid var(--vscode-textLink-foreground);">
                        ${formattedText}
                    </div>
                `;

                messageElement.innerHTML = styledText;
            }

            // Add a subtle animation to show the message has been updated
            messageElement.style.animation = 'none';
            setTimeout(function() {
                messageElement.style.animation = 'fadeIn 0.3s';
            }, 10);
        }
    </script>
</body>
</html>
